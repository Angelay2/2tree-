#include "stack.h"

// 栈(受限的线性表)和队列
// 所有的结构底层无非是两种结构(一种是连续的结构, 一种是不连续的结构)
// 1. 栈: 一种特殊的线性表, 其值只允许在固定的一端进行插入和删除元素操作, 
// 进行数据插入和删除操作的一端称为栈顶, 另一端称为栈底. 栈中的数据元素遵守后进先出的原则
// 压栈; 栈的插入操作叫做进栈/压栈/入栈, 入数据在栈顶
// 出栈: 栈的删除操作叫做出栈, 出数据也在栈顶.
// 栈底表示第一个元素放的位置 栈顶表示最后一个元素放的位置

// 栈的实现: 栈的实现一般可以使用数组或者链表, 相对而言数组的结构实现更优一些, 因为数组在尾上插入数据
// 的代价比较小,
// 可以用顺序表的尾插对应栈的入栈, 尾删对应栈的出栈
// 用单链表的头插对应栈的入栈    头删对应栈的出栈 
// 两者对应栈的操作都是O(1),  但是如果两个的性能都差不多的情况下, 优先选择顺序表
// 栈其实是一个更加简单的顺序表


// 栈的初始化
// 相当于开一个n的大小空间
// 先申请n的大小的存放数组的空间(可以容纳的元素个数 * 元素类型大小(即所占的字节))
// 再将元素个数设置为0, 容量设置最多可以存放n个元素(所以先需要申请存放元素的空间)
// 直接让已经定义好的指针指向该块空间
// 参数为结构体指针定义的栈和元素个数n 直接用定义的栈st可以访问其结构体内部定义的元素
void stackInit(Stack* st, size_t n){
	st->_array = (SDatatype*)malloc(sizeof(SDatatype) * n);
	st->_size = 0;
	st->_capacity = n;// 当前能存放多少元素 
}

// 入栈
// 等到存入元素的现有个数和容量一样 则证明容量满了 要增容 继续让st->_array指向新申请的空间(更新空间)
// 增容即申请空间(为可以容纳的元素个数乘以类型大小)以及增加可以容纳的元素个数(最直接的办法乘以2)
// 申请空间需将之前申请的空间初始化, 让_array指向重新申请的新空间(大小为2*原始容量) 
// 申请完空间再更新容量
void stackPush(Stack* st, SDatatype data){
	// 检查容量
	if (st->_size == st->_capacity){
		// 增加空间和容量, 元素个数不变
		st->_array = (SDatatype*)realloc(st->_array, sizeof(SDatatype) * 2 * st->_capacity);
		st->_capacity *= 2; 
	}
	// 再进行尾插 让元素个数+1, 下标为size-1的为原始最后一个元素 新的元素应存放在下标为size的位置
	// 所以更新数组 即将data赋给数组下标为size的元素;
	st->_array[st->_size++] = data;
}

// 出栈 栈不为空 直接减小个数即可
void stackPop(Stack* st){
	if (st->_size > 0){
		--st->_size;
	}
}

// 获取栈顶元素(即最后一个进入的元素)
SDatatype stackTop(Stack* st){
	return st->_array[st->_size - 1];
}

// 获取栈的元素个数
size_t stackSize(Stack* st){
	return st->_size;
}

// 栈是否为空
int stackEmpty(Stack* st){
	if (st->_size == 0)
		return 1;
	return 0;
}

// 不能打印栈, 要想访问栈空间的元素, 只能使用pop的操作
// 打印会破坏栈的特点, 如果打印的话,顺序表就不能保证后进先出的规则了, 可以是任意顺序了,
// 栈的销毁(把空间还给系统)
void stackDestory(Stack* st){
	// 如果数组还存在 那就释放数组
	if (st->_array){
		free(st->_array);
		// 空间还给数组后. 数组 容量都为0;
		st->_size = st->_capacity = 0;
	}
}
